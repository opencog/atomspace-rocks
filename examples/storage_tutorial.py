#! /usr/bin/env python3
#
# storage_tutorial.py
#
"""
Tutorial on how to use RocksStorageNode to save selectively save
individual Atoms or entire AtomSpaces to disk. This is a fairly basic
demo; the scheme files in this directory provide a larger variety of
examples. As the scheme examples are written in a direct fashion, it
should be fairly obvious how to port those examples to Python, as
desired.
"""

# Boilerplate
from opencog.atomspace import AtomSpace
from opencog.type_constructors import *
from opencog.storage_rocks import *

# AtomSpace cne be given a name; if not supplied, one is autogenerated.
space = AtomSpace("my basic space")
set_thread_atomspace(space)

# Basic Atomese tutorial: a labelled directed graph edge.
# In ASCII graphics:
#
#                      "some edge label"
#    "from vertex" ------------------------> "to vertex"
#
# which in Atomese, becomes
#
#    (Edge (Predicate "some edge label")
#            (List (Item "from vertex") (Item "to vertex")))
#
# and for python, the parens get re-arranged and commas are inserted:
#
#    Edge (Predicate ("some edge label"),
#          List (Item ("from vertex"), Item ("to vertex")))
#
e = Edge(
	Predicate("My collection of URLs"),
	List(
		Item("file:///Home Computer/folders/My photo album"),
		Item("Fantastic Sunset on Sunday.jpg")))

print("Here's your data:", e)

# -------------------------------------------
# AtomSpace contents can be stored and loaded from disk, and sent over
# the net (to other AtomSpaces). All such operations use exactly the
# same API, given by the StorageNode. This demo illustrates the API by
# using it with RocksStorageNode, which is built on top of the RocksDB
# disk database.  Rocks is nice, because it requires no config to use.

# Create a RocksDB StorageNode.
# The rocks:// URL specifies a directory in the local filesystem.
storage = RocksStorage("rocks:///tmp/foo")

# Open a connection to storage using message-passing.
# The StorageNode API works by sending messages to StorageNodes via
# set_value(). All messages are PredicateNodes naming the operation.
space.set_value(storage, Predicate("*-open-*"), VoidValue())
print("Opened connection to storage")

# Store the one and only edge created above.
space.set_value(storage, Predicate("*-store-atom-*"), e)
print("Stored the edge")

# Close the connection to storage.
space.set_value(storage, Predicate("*-close-*"), VoidValue())
print("Closed the connection to storage")

# The entire contents of the AtomSpace could have been stored with
# just one simple command:
#    space.set_value(storage, PredicateNode("*-store-atomspace-*"), space)
# This was not done, mostly just to show that one can also do granular
# save and restore.

# -------------------------------------------
# The rest of this demo is about restoring the Atom that was just saved.
# To prove that this works, the AtomSpace will be cleared. To prove that
# it was cleared, look at the contents before and after.

# Define a utility printer
def prt_atomspace_contents(asp) :
	print("AtomSpace contains a total of " + str(len(asp)) + " Atoms")
	if 0 < len(asp) :
		print("These are:")
	count = 0
	for atom in asp:
		count += 1
		print("Atom " + str(count) + ".... " + str(atom))

print("The AtomSpace before clearing:")
prt_atomspace_contents(space)

print("\nWill now clear the AtomSpace.")
space.clear()
print("The AtomSpace size after clearing: ", len(space))
prt_atomspace_contents(space)

# -------------------------------------------
# The clear clobbers the StorageNode; create it again.
storage = RocksStorageNode("rocks:///tmp/foo")
space.set_value(storage, Predicate("*-open-*"), VoidValue())
print("Reopened connection to storage")

# Bulk restore: load the entire AtomSpace from storage in one step.
# This restores everything, and is the easiest way to load data.
print("\nBulk restore: loading entire AtomSpace from storage...")
space.set_value(storage, Predicate("*-load-atomspace-*"), space)

# Close storage for now.
space.set_value(storage, Predicate("*-close-*"), VoidValue())

print("After bulk restore:")
prt_atomspace_contents(space)

# -------------------------------------------
# Bulk restore of everything can be impractical, if the dataset is
# large. In this case, individual Atoms, and even Values, can be loaded,
# one at a time, or in groups. Storae can even be queried (!); see the
# scheme examples for details; they port over easily to python.
#
print("\n--- Demonstrating selective fetch operations ---")

# Clear and start over.
space.clear()
print("Cleared AtomSpace again, size is now:", len(space))

# Reopen storage
storage = RocksStorage("rocks:///tmp/foo")
space.set_value(storage, Predicate("*-open-*"), VoidValue())

# Restore one atom: the predicate, whose name "My collection" we already
# know, as if by magic.  The fetch-atom message argument must be either
# a ListLink or a LinkValue containing the AtomSpace and the atom to
# fetch. Since Links are *always* stored in the AtomSpace, and Values
# are *never* stored in the AtomSpace, ths gives you some flexibility
# in how to represent the arguments. As a general rule, one should not
# pollute the AtomSpace with suprious transient temporary junk, and
# for this, the LinkValue is the obvious choice.

print("\nSelective fetch: restore just one atom by name.")
url_pred = Predicate("My collection of URLs")
space.set_value(storage, Predicate("*-fetch-atom-*"),
	LinkValue([space, url_pred]))

# The requested Atom, and all of the Values attached to it, have been
# placed directly into the AtomSpace. That is why there is no need to
# say 'my_stuff = space.set_value(storage, ...)' -- everything goes
# straight into the current AtomSpace. Now, the above fetch is a bit
# silly, because there are no Values attached to "My Collection"; we'll
# get back to that.
prt_atomspace_contents(space)

# Restore all Edges held in storage, by fetching the incoming set.
print("\nFetch incoming set: restore all links containing that atom.")
space.set_value(storage, Predicate("*-fetch-incoming-set-*"),
	LinkValue([space, url_pred]))

# Close the connection to storage.
space.set_value(storage, PredicateNode("*-close-*"), VoidValue())

print("\nAfter selective restore:")
prt_atomspace_contents(space)

print("Good bye!")
#
# The StorageNode API works via message-passing. Messages that have
# mandatory arugments are sent by saying
#
#    `atomspace.set_value(storage, message, args)`.
#
# A small handfule of messages do not require arguments; these work by
# saying
#
#    result = `atomspace.get_value(storage, message)`.
#
# Messages are always PredicateNodes naming the operation.
# Common messages:
#
# * `*-open-*` and `*-close-*` to open/close storage connections.
#   Args: VoidValue()
#
# * `*-store-atom-*` to store an atom and all its values.
#   Args: the atom to store
#
# * `*-fetch-atom-*` to fetch an atom and all its values.
#   Args: LinkValue([atomspace, atom])
#
# * `*-store-atomspace-*` and `*-load-atomspace-*` for bulk operations.
#   Args: the AtomSpace
#
# * `*-fetch-incoming-set-*` to fetch all links containing an atom.
#   Args: LinkValue([atomspace, atom])
#
# * `*-fetch-incoming-by-type-*` to fetch links of a specific type.
#   Args: LinkValue([atomspace, atom, TypeNode("EdgeLink")])
#
# * `*-store-value-*` and `*-fetch-value-*` for individual values.
#   Args: LinkValue([atom, key])
#
# * `*-update-value-*` performs an atomic read-modify-write (increment).
#   Args: LinkValue([atom, key, delta])
#
# * `*-delete-*` and `*-delete-recursive-*` to remove atoms from storage.
#   Args: LinkValue([atomspace, atom])
#
# * `*-barrier-*` for multi-thread synchronization.
#   Args: atomspace
#
# * `*-connected?-*` to check connection status.
#   Use: atomspace.get_value(storage, PredicateNode("*-connected?-*"))
#
# * `*-monitor-*` to get performance/debugging info.
#   Use: atomspace.get_value(storage, PredicateNode("*-monitor-*"))
#
# See https://wiki.opencog.org/w/StorageNode for API documentation and
# longer description of the messages. A complete list of messages for
# a given StorageNode can be optained by saying
#
#     storage.getMessages()
#
# THE END.
# ---------------------------------------------------------------------
